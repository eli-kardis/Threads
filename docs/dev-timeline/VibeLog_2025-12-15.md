# 📅 Vibe Log Timeline: 2025-12-15

> **Note:** `/commit` 명령으로 자동 기록되는 Raw Data 파일입니다.
> 하루가 끝나면 `/devlog` 명령어를 사용하여 최종 개발일지를 생성하세요.

**프로젝트:** Threads to Notion Sync (Chrome Extension)
**생성 시간:** 2025-12-15 15:30

---

## ⏰ [15:30] 커밋 #1

### 1. 🗣️ User Request (Raw Data)
**원본 프롬프트:**
> 아직도 메인화면에서 동기화 시작 버튼을 누르면 노션에 동기화가 잘 되는데, 여기서 지금 동기화를 누르면 새로운 글이 동기화가 안돼

> 왜 옵션의 버튼과 팝업의 버튼의 동작 차이가 있는거야?

> 5분에 10개로 변경하자. 팝업 버튼도 50개 말고 30개로 변경해줘

**AI가 파악한 의도:**
- popup의 "지금 동기화" 버튼과 options의 "동기화 시작" 버튼의 동작 불일치 문제 해결
- 두 버튼의 동기화 로직을 통일하여 일관된 동작 보장
- API Rate limit 방지를 위한 호출량 최적화

**요청에서 누락/모호했던 정보:**
- 초기에 두 버튼의 의도적 차이인지, 버그인지 불명확했음
- Rate limit 문제는 사용자가 직접 지적해주어 개선

### 2. 🏗️ Implementation
**변경된 파일:**
| 파일 경로 | 작업 | 내용 |
| :--- | :--- | :--- |
| src/background.js | 수정 | performSync()에 limit 파라미터 추가, ID 기반 필터링으로 변경 |
| src/storage/storage.js | 수정 | 기본 syncInterval 1분 → 5분 변경 |
| src/ui/options.js | 수정 | 기본 syncInterval 1분 → 5분 변경 |

**핵심 코드 (Core Logic):**
```javascript
// background.js - performSync() 파라미터 추가
async function performSync(options = {}) {
  const { limit = 30 } = options;
  // ...
  const response = await threadsApi.getUserThreads(settings.threadsToken, { limit });
  // lastSyncTime 필터링 제거 → ID 기반 체크로 변경
  for (const thread of recentThreads) {
    const alreadySynced = await storage.isThreadSynced(thread.id);
    if (alreadySynced) continue;
    // ...
  }
}

// 알람에서 호출 (자동 동기화: 10개)
await performSync({ limit: 10 });

// 메시지 핸들러에서 호출 (팝업 버튼: 30개)
return await performSync({ limit: 30 });
```

**적용 기술/라이브러리:**
- Chrome Extension Storage API
- Threads Graph API

### 3. 🐞 Trouble & Fix
**에러 발생 여부:** ❌ 없음

**Error Log:**
```
None (별도 에러는 API access blocked 이슈로 Meta 앱 검수 대기 중)
```

**원인 분석:**
- popup의 performSync()는 lastSyncTime 기반 필터링 사용
- options의 syncFromDate()는 ID 기반 체크 사용
- 두 로직의 불일치로 popup에서 새 글을 놓칠 수 있었음

**해결 과정:**
- 두 버튼 모두 ID 기반 체크 방식으로 통일
- 시간 기반 필터링 제거하여 안정성 확보

### 4. 💡 Prompt Reflection (Micro-Coaching)
**😅 이 부분이 아쉬웠다:**
- 초기에 문제를 잘못 분석하여 전체 게시글을 조회하는 비효율적인 코드로 수정했다가 롤백

**✅ 이렇게 요청했으면 완벽했다 (Best Practice):**
> "popup과 options의 동기화 버튼이 다르게 동작해. popup은 lastSyncTime 기반이고 options는 ID 기반인데, 둘 다 ID 기반으로 통일해줘. 그리고 API 호출량을 줄이기 위해 자동 동기화는 5분/10개, 수동은 30개로 해줘."

**🎓 배운 점:**
- 동일한 목적의 기능은 동일한 로직으로 통일해야 유지보수가 용이함
- API Rate limit을 고려한 설계가 중요함
- 문제 해결 시 전체 흐름을 파악한 후 수정해야 함

---

## ⏰ [18:50] 커밋 #2

### 1. 🗣️ User Request (Raw Data)
**원본 프롬프트:**
> 인사이트 불러올 때 공유수도 불러오게 되어있어?

> shares 있어. shares까지 불러오도록 수정해서 가장 최신 글만 테스트해봐

> 지금 내 노션 데이터베이스의 '공유'로 설정되어있는 건 그럼 인용이랑 매핑되어있느거야?

> 추가해

> 이제 대시보드도 바꿔야겠다. 조회수, 좋아요, 댓글, 리포스트만 나와있잖아. 여기에 인용, 공유까지 만들어줘. 지금처럼 한줄로 표시되게 각 박스 크기를 줄여서 알맞게 맞춰줘. 아래의 스레드 기록에도 인용과 공유도 추가해주고. 평균 참여율 로직에 인용과 공유도 적용해서 다시 짜줘.

> 노션에 저장된 데이터와 대시보드에 있는 데이터가 맞지 않는다고. 뭐가 문제인지 꼼꼼히 찾아봐

**AI가 파악한 의도:**
- Threads API의 `shares` 메트릭을 인사이트에 추가
- 노션 필드 매핑에서 quotes(인용)와 shares(공유) 분리
- 대시보드에 인용/공유 통계 박스 및 테이블 열 추가
- 참여율 계산에 인용(2배), 공유(1.5배) 가중치 적용
- 노션-대시보드 데이터 불일치 문제 해결

**요청에서 누락/모호했던 정보:**
- 초기에 shares가 API에 존재하는지 불확실했음
- 데이터 불일치의 근본 원인(Storage에 shares 필드 누락)은 탐색 후 발견

### 2. 🏗️ Implementation
**변경된 파일:**
| 파일 경로 | 작업 | 내용 |
| :--- | :--- | :--- |
| src/api/threads.js | 수정 | getThreadInsights에 shares 메트릭 추가 |
| src/api/notion.js | 수정 | buildProperties, updatePageStats에 shares 필드 추가 |
| src/ui/options.html | 수정 | quotes→인용, shares→공유 필드 매핑 UI 분리 |
| src/ui/options.js | 수정 | shares 필드 매핑 로직 추가 |
| src/ui/dashboard.html | 수정 | 6열 그리드로 변경, 인용/공유 카드 추가, 테이블 열 추가 |
| src/ui/dashboard.js | 수정 | updateStatsCards, updateHistoryTable, calculateEngagementRate에 quotes/shares 추가 |
| src/background.js | 수정 | getAggregatedInsights에 shares 합산 추가 |
| src/storage/storage.js | 수정 | addThreadPageMapping, updateThreadInsights에 shares 필드 추가 |

**핵심 코드 (Core Logic):**
```javascript
// threads.js - shares 메트릭 추가
metric: 'views,likes,replies,reposts,quotes,shares'

// storage.js - 데이터 불일치 해결
insights: insights || { views: 0, likes: 0, replies: 0, reposts: 0, quotes: 0, shares: 0 }

mappings[index].insights = {
  views: insights.views || 0,
  likes: insights.likes || 0,
  replies: insights.replies || 0,
  reposts: insights.reposts || 0,
  quotes: insights.quotes || 0,
  shares: insights.shares || 0  // ← 핵심 수정
};

// dashboard.js - 참여율 계산
const engagementCount = (insights.likes || 0) +
                        (insights.replies || 0) * 2 +      // 댓글 2배
                        (insights.reposts || 0) * 1.5 +    // 리포스트 1.5배
                        (insights.quotes || 0) * 2 +       // 인용 2배
                        (insights.shares || 0) * 1.5;      // 공유 1.5배
```

**적용 기술/라이브러리:**
- Threads Graph API (shares metric)
- Chrome Extension Storage API
- CSS Grid (6열 레이아웃)

### 3. 🐞 Trouble & Fix
**에러 발생 여부:** ✅ 있음

**Error Log:**
```
노션에는 shares가 저장되지만 대시보드에는 항상 0으로 표시됨
```

**원인 분석:**
- **직접적 원인:** storage.js의 두 함수에서 shares 필드 누락
  - `addThreadPageMapping()`: 새 게시글 저장 시 shares 제외
  - `updateThreadInsights()`: 인사이트 업데이트 시 shares 제외
- **근본 원인:** 노션은 Threads API 데이터를 직접 저장하지만, 대시보드는 Storage 데이터를 사용하여 데이터 소스 불일치 발생

**해결 과정:**
- storage.js의 두 함수에 `shares: 0` 및 `shares: insights.shares || 0` 추가
- 이후 REFRESH_STATS 실행하여 기존 데이터 백필 필요

### 4. 💡 Prompt Reflection (Micro-Coaching)
**😅 이 부분이 아쉬웠다:**
- "공유수"가 reposts인지 shares인지 초기에 혼동이 있었음
- 데이터 불일치 원인을 찾는 데 여러 파일을 탐색해야 했음

**✅ 이렇게 요청했으면 완벽했다 (Best Practice):**
> "Threads API의 shares 메트릭을 추가해줘. 노션 필드 매핑에서 quotes는 '인용', shares는 '공유'로 분리하고, 대시보드에도 6개 통계(조회수, 좋아요, 댓글, 리포스트, 인용, 공유)를 한 줄로 표시해줘. 참여율 계산에 인용 2배, 공유 1.5배 가중치 적용하고, Storage에도 shares 필드를 추가해서 노션-대시보드 데이터가 일치하게 해줘."

**🎓 배운 점:**
- 새 필드 추가 시 전체 데이터 흐름(API → Storage → UI)을 확인해야 함
- 노션과 대시보드가 다른 데이터 소스를 사용할 때 동기화 문제 발생 가능
- 필드 추가는 단순해 보여도 여러 파일에 걸쳐 수정이 필요함

---

## ⏰ [23:12] 커밋 #3

### 1. 🗣️ User Request (Raw Data)
**원본 프롬프트:**
> 옵션의 동기화 로직은 그대로 유지하고, 팝업의 동기화 버튼을 클릭하면 작성일 기준 14일 이전까지의 게시글 인사이트 새로고침 + 가장 마지막 게시글의 작성시간 이후로 새로운 글이 있는지 체크 후 동기화 하게끔 수정해줘

> 대시보드의 새로고침도 팝업의 동기화 버튼과 동일한 로직으로 변경해줘

**AI가 파악한 의도:**
- 팝업 동기화 버튼의 로직을 확장: 단순 새 글 동기화 → 인사이트 새로고침 + 새 글 동기화
- 14일 이내 게시글의 통계 데이터 자동 새로고침
- 마지막 동기화된 게시글 이후의 새 글만 효율적으로 동기화
- 대시보드 새로고침 버튼도 동일한 로직으로 통일

**요청에서 누락/모호했던 정보:**
- 없음 - 요청이 명확했음

### 2. 🏗️ Implementation
**변경된 파일:**
| 파일 경로 | 작업 | 내용 |
| :--- | :--- | :--- |
| src/background.js | 추가 | `popupSync()` 함수 추가 (14일 인사이트 새로고침 + 새 글 동기화) |
| src/background.js | 수정 | SYNC_NOW 핸들러가 `popupSync()` 호출하도록 변경 |
| src/ui/popup.js | 수정 | 결과 표시 형식 변경 (새로고침 + 동기화 건수) |
| src/ui/dashboard.js | 수정 | REFRESH_STATS → SYNC_NOW로 변경, 결과 표시 추가 |

**핵심 코드 (Core Logic):**
```javascript
// background.js - popupSync() 함수 (핵심 로직)
async function popupSync() {
  // === STEP 1: 14일 이내 게시글 인사이트 새로고침 ===
  const fourteenDaysAgo = new Date();
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);

  const recentMappings = mappings.filter(m => {
    if (!m.postCreatedAt) return false;
    return new Date(m.postCreatedAt) >= fourteenDaysAgo;
  });

  for (const mapping of recentMappings) {
    const insights = await threadsApi.getThreadInsights(settings.threadsToken, mapping.threadId);
    await notionApi.updatePageStats(...);
    await storage.updateThreadInsights(mapping.threadId, insights);
    refreshedCount++;
  }

  // === STEP 2: 마지막 게시글 작성시간 이후 새 글 동기화 ===
  let latestPostTime = null;
  for (const m of mappings) {
    if (m.postCreatedAt) {
      const postTime = new Date(m.postCreatedAt);
      if (!latestPostTime || postTime > latestPostTime) {
        latestPostTime = postTime;
      }
    }
  }

  // 새 글 동기화 (마지막 게시글 이후만)
  for (const thread of recentThreads) {
    if (latestPostTime && thread.createdAt) {
      const threadTime = new Date(thread.createdAt);
      if (threadTime <= latestPostTime) continue;
    }
    await syncThreadToNotion(thread, settings);
    syncedCount++;
  }

  return { success: true, refreshedCount, syncedCount };
}

// popup.js / dashboard.js - 결과 표시
if (result.success) {
  const parts = [];
  if (result.refreshedCount > 0) parts.push(`${result.refreshedCount}개 새로고침`);
  if (result.syncedCount > 0) parts.push(`${result.syncedCount}개 동기화`);
  btn.innerHTML = parts.length > 0 ? `✓ ${parts.join(', ')}` : '✓ 최신 상태';
}
```

**적용 기술/라이브러리:**
- Chrome Extension Message Passing
- Threads Graph API
- Notion API

### 3. 🐞 Trouble & Fix
**에러 발생 여부:** ❌ 없음

**Error Log:**
```
None
```

**원인 분석:**
- N/A

**해결 과정:**
- N/A

### 4. 💡 Prompt Reflection (Micro-Coaching)
**😅 이 부분이 아쉬웠다:**
- 없음 - 요청이 명확하고 구체적이었음

**✅ 이렇게 요청했으면 완벽했다 (Best Practice):**
> 이번 요청은 이미 완벽했음: "팝업의 동기화 버튼을 클릭하면 작성일 기준 14일 이전까지의 게시글 인사이트 새로고침 + 가장 마지막 게시글의 작성시간 이후로 새로운 글이 있는지 체크 후 동기화"

**🎓 배운 점:**
- 기능 요청 시 "무엇을 + 어떤 기준으로 + 언제" 명시하면 구현이 명확해짐
- 동일한 로직을 여러 곳에서 사용할 때 별도 함수로 분리하면 유지보수가 용이함
- 팝업/대시보드 등 여러 UI에서 같은 기능을 제공할 때 로직 통일이 중요함
