# 📅 Vibe Log Timeline: 2025-12-19

> **Note:** `/commit` 명령으로 자동 기록되는 Raw Data 파일입니다.
> 하루가 끝나면 `/devlog` 명령어를 사용하여 최종 개발일지를 생성하세요.

**프로젝트:** Threads to Notion Sync (Chrome Extension)
**생성 시간:** 2025-12-19 17:45

---

## ⏰ [17:45] 커밋 #1

### 1. 🗣️ User Request (Raw Data)
**원본 프롬프트:**
> 데이터를 불러오는 속도, 대시보드 로딩 속도를 최적화할 수 있는 방법이 있는지 꼼꼼하게 점검후 현실적인 해결방안 제시

> 플랜모드로 방금 네가 말한 수정사항들 다시 꼼꼼하게 검토해봐

> 커밋하고 빌드해줘

**AI가 파악한 의도:**
- 팝업/대시보드의 데이터 로딩 속도 개선
- Threads API 중복 호출 제거
- 체감 로딩 속도 향상

**요청에서 누락/모호했던 정보:**
- 없음 - 플랜 모드를 통해 최적화 방안의 위험도까지 검토하여 안전하게 진행

### 2. 🏗️ Implementation
**변경된 파일:**
| 파일 경로 | 작업 | 내용 |
| :--- | :--- | :--- |
| src/background.js | 수정 | 요청 결합, 팔로워 캐싱(1분), 통합 API 추가 |
| src/ui/popup.js | 수정 | GET_ALL_INSIGHTS 사용 (3회→1회) |
| src/ui/dashboard.js | 수정 | GET_ALL_INSIGHTS 사용 (2회→1회) |

**핵심 코드 (Core Logic):**
```javascript
// 1. 팔로워 캐싱 (1분 TTL)
const FOLLOWERS_CACHE_TTL = 60 * 1000;
let followersCache = { count: 0, fetchedAt: 0 };

async function getCachedFollowersCount(token) {
  const now = Date.now();
  if (now - followersCache.fetchedAt < FOLLOWERS_CACHE_TTL && followersCache.count > 0) {
    return followersCache.count;
  }
  const accountInsights = await threadsApi.getAccountInsights(token, { period: 7 });
  followersCache = { count: accountInsights.followers_count || 0, fetchedAt: now };
  return followersCache.count;
}

// 2. 요청 결합 (Request Coalescing)
const pendingInsightsRequests = new Map();

async function getAggregatedInsightsWithCoalescing(period) {
  const cacheKey = `insights_${period}`;
  if (pendingInsightsRequests.has(cacheKey)) {
    return pendingInsightsRequests.get(cacheKey);
  }
  const promise = getAggregatedInsights(period);
  pendingInsightsRequests.set(cacheKey, promise);
  try {
    return await promise;
  } finally {
    pendingInsightsRequests.delete(cacheKey);
  }
}

// 3. 통합 인사이트 API
async function getAllInsights() {
  const mappings = await storage.getThreadPageMappings();
  const settings = await storage.getAllSettings();
  return {
    week: { ...aggregateByPeriod(mappings, 7), followers_count },
    month: { ...aggregateByPeriod(mappings, 30), followers_count },
    total: { ...aggregateByPeriod(mappings, 90), followers_count },
    followers_count: await getCachedFollowersCount(settings.threadsToken)
  };
}
```

**적용 기술/라이브러리:**
- Request Coalescing 패턴 (동일 요청 결합)
- In-memory 캐싱 (1분 TTL)
- Chrome Extension Message API

### 3. 🐞 Trouble & Fix
**에러 발생 여부:** ❌ 없음

**Error Log:**
```
None
```

**원인 분석:**
플랜 모드에서 사전 검토를 통해 위험 요소를 미리 파악함:
- 5분 캐싱 → 데이터 불일치 위험 → 1분으로 단축
- 직접 캐싱 → 동시 요청 문제 → 요청 결합 우선 적용

**해결 과정:**
사전 분석으로 문제 회피

### 4. 💡 Prompt Reflection (Micro-Coaching)
**😅 이 부분이 아쉬웠다:**
- 최적화 요청은 좋았지만, "플랜 모드로 검토"를 명시적으로 요청한 것이 안전한 결과물을 만듦

**✅ 이렇게 요청했으면 완벽했다 (Best Practice):**
> "대시보드/팝업 로딩 속도 최적화해줘. 단, 데이터 일관성 문제가 생기지 않도록 플랜 모드로 검토 후 진행해줘"

**🎓 배운 점:**
- API 캐싱 시 TTL 설정은 데이터 특성에 맞게 보수적으로 (5분 → 1분)
- Request Coalescing은 부작용 없이 효과적인 최적화 방법
- 통합 API로 메시지 왕복 횟수를 줄이면 체감 속도 향상
