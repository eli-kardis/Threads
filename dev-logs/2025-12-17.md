# 📅 개발일지: 2025-12-17

---

## 1. 📝 기본 정보

| 항목 | 내용 |
|------|------|
| **날짜** | 2025년 12월 17일 (화) 오후 |
| **프로젝트** | Threads → Notion Sync Chrome Extension |
| **작업 요약** | 보안/품질 이슈 7개 수정 + Claude Code 상태표시줄 버그 해결 |
| **진행률** | 100% (배포 준비 완료) |

**오늘의 핵심 성과:**
Chrome 확장 프로그램의 **보안 취약점(XSS)**, **동시성 버그(Race Condition)**, **데이터 불일치(Storage 키)** 등 7개 품질 이슈를 모두 해결하고 웹스토어 배포 준비를 완료했습니다. 추가로 Claude Code의 **상태표시줄 버그**도 수정하여 정확한 컨텍스트 사용량을 표시하도록 개선했습니다.

---

## 2. 🗣️ 요구사항 역추적 (Prompt Archive)

### [요청 1] API Rate Limit 점검
> "지금 보내주는 내용을 꼼꼼하게 읽고 api 리미트가 몇인지 알려줘봐"

* **의도:** Threads API 공식 문서를 바탕으로 Rate Limit 제한을 정확히 파악하고, 우리 앱이 제한에 걸리지 않는지 검증
* **AI의 해석:**
  - 일반 API 호출: 4800 × 노출 횟수 (최소 48,000/일)
  - 게시물 발행: 250개/일, 답글: 1,000개/일
  - 우리 앱의 예상 사용량: ~2,100 API/일 (제한의 4.4%)
* **Gap:** 없음 - API 문서 전문을 제공해서 정확한 분석이 가능했음

### [요청 2] 코드베이스 품질 점검
> "지금 우리가 만들어놓은 로직을 바탕으로, 유저 1명당 하루 리미트에 걸리진 않는지 점검해봐"

* **의도:** 실제 코드의 API 호출 패턴을 분석해서 Rate Limit 초과 가능성 검증
* **AI의 해석:** 자동 동기화(5분 간격 × 288회), 수동 동기화, 일일 통계 새로고침 등 모든 시나리오 분석
* **Gap:** 없음 - 코드베이스가 구조적으로 잘 정리되어 있어 분석이 용이했음

### [요청 3] 보안 이슈 체크리스트 검토
> "ISSUES_TO_FIX.md 파일을 읽고 추가로 확인해야하는 사항을 체크해봐"

* **의도:** 기존에 발견된 이슈들의 실제 수정 여부 확인
* **AI의 해석:** 7개 미수정 이슈 식별 (XSS, Storage 키, Race Condition, Notion API 에러 처리, Rate Limit 타임아웃, 에러 메시지, 콘솔 로그)
* **Gap:** 없음 - 이슈 문서가 우선순위, 파일 위치, 해결 방안까지 상세히 기록되어 있었음

### [요청 4] 수정 범위 결정
> "배포 전 어느 범위까지 수정할까요?" → **"전체 수정"** 선택

* **의도:** Critical부터 Low까지 7개 이슈 전체 해결
* **AI의 해석:** 우선순위에 따라 Critical(XSS) → High(Storage, Race Condition) → Medium → Low 순으로 수정 진행
* **Gap:** 없음 - 선택지가 명확하게 제시되어 의사결정이 빨랐음

### [요청 5] Claude Code 상태표시줄 버그 수정
> "지금 상태표시줄에 표시되는 진행률 바에 오류가 있어. 현재 컨텍스트 사용량이 아닌 세션 누적 토큰을 반환하여 컨텍스트 바가 부정확해"

* **의도:** 상태표시줄이 현재 컨텍스트 사용량을 정확히 표시하도록 수정
* **AI의 해석:** `total_input_tokens` → `current_usage.input_tokens` 필드로 변경 필요
* **Gap:** 초기에 정확한 필드 경로가 불분명했으나, 사용자가 `current_usage.input_tokens`를 명시해줌

---

## 3. 🏗️ 구현 결과물 (Code & Structure)

### 변경된 파일 구조
```
Threads/
├── src/
│   ├── api/
│   │   └── notion.js          ✏️ Rate Limit 타임아웃 추가
│   ├── ui/
│   │   └── options.js         ✏️ XSS 수정, Storage 키, 에러 메시지, 로그 정리
│   └── background.js          ✏️ Race Condition 수정, 로그 정리
├── docs/
│   └── dev-timeline/
│       └── VibeLog_2025-12-17.md  ✨ 신규 생성
├── dev-logs/
│   └── 2025-12-17.md          ✨ 전체 개발일지
├── ISSUES_TO_FIX.md           ✏️ 수정 완료 항목 체크
└── ~/.claude/
    └── statusline.sh          ✏️ 컨텍스트 사용량 필드 수정 (프로젝트 외부)
```

### 파일 변경 요약

| 파일 경로 | 변경 유형 | 핵심 변경 내용 |
|----------|---------|--------------|
| `src/ui/options.js` | 수정 | innerHTML XSS 취약점 → DOM API 헬퍼 함수로 교체 |
| `src/ui/options.js` | 수정 | `tokenExpiresAt` → `threadsTokenExpiresAt` 키 일치화 |
| `src/ui/options.js` | 수정 | 에러 메시지 사용자 친화적으로 변경 |
| `src/ui/options.js` | 수정 | `console.log` → 조건부 `log` 함수로 교체 |
| `src/background.js` | 수정 | `isSyncing` 플래그 → Promise 기반 락 패턴 |
| `src/background.js` | 수정 | `console.log` → 조건부 `log` 함수로 교체 |
| `src/api/notion.js` | 수정 | Rate Limit 대기 시 최대 타임아웃 5초 설정 |
| `ISSUES_TO_FIX.md` | 수정 | 7개 이슈 수정 완료 체크 |
| `dev-logs/2025-12-17.md` | 생성 | 전체 개발일지 생성 |
| `~/.claude/statusline.sh` | 수정 | `total_input_tokens` → `current_usage.input_tokens` |

### 핵심 구현 로직

#### 1. XSS-Safe DOM 헬퍼 함수
innerHTML에 동적 데이터를 삽입하면 XSS(크로스 사이트 스크립팅) 공격에 취약해집니다.
DOM API를 사용하면 `textContent`가 자동으로 이스케이프 처리해줍니다.

```javascript
/**
 * 연결됨 상태 UI 생성 (XSS-safe)
 * innerHTML 대신 DOM API를 사용해 악성 스크립트 주입 방지
 */
function createConnectedUI(service, subText) {
  const container = document.createElement('div');
  container.style.cssText = 'background: #D1FAE5; padding: 16px; border-radius: 10px; text-align: center;';

  const icon = document.createElement('span');
  icon.style.fontSize = '24px';
  icon.textContent = '✅';

  const title = document.createElement('p');
  title.style.cssText = 'margin-top: 8px; color: #065F46; font-weight: 600;';
  title.textContent = service === 'threads' ? 'Threads 연결됨' : 'Notion 연결됨';

  const sub = document.createElement('p');
  sub.style.cssText = 'font-size: 12px; color: #047857; margin-top: 4px;';
  // textContent는 자동으로 HTML 이스케이프 처리
  sub.textContent = service === 'threads'
    ? `User ID: ${subText || 'N/A'}`
    : (subText || 'Workspace');

  container.appendChild(icon);
  container.appendChild(title);
  container.appendChild(sub);

  return container;
}

// 사용 예: innerHTML 대신 replaceChildren 사용
oauthSection.replaceChildren(createConnectedUI('threads', data.threadsUserId));
```

#### 2. Promise 기반 동시성 제어 (Race Condition 해결)
기존 `isSyncing = true/false` 플래그 방식은 비동기 환경에서 Race Condition이 발생할 수 있습니다.
Promise 기반 락은 동시 요청 시 기존 작업의 결과를 공유합니다.

```javascript
// 동기화 상태 (Promise 기반 락)
let syncPromise = null;

// isSyncing getter (하위 호환성 유지)
const isSyncing = () => syncPromise !== null;

async function popupSync() {
  // 이미 동기화 중이면 기존 작업 결과를 반환 (중복 실행 방지)
  if (syncPromise) {
    return syncPromise;
  }

  // 실제 동기화 로직을 Promise로 래핑
  syncPromise = doPopupSync();

  try {
    return await syncPromise;
  } finally {
    // 작업 완료 후 락 해제
    syncPromise = null;
  }
}

async function doPopupSync() {
  // 실제 동기화 로직...
}
```

#### 3. Claude Code 상태표시줄 수정
상태표시줄이 세션 누적 토큰 대신 실제 현재 컨텍스트 사용량을 표시하도록 수정했습니다.

```bash
# Before (세션 누적 토큰 - 부정확)
CURRENT_TOKENS=$(echo "$input" | jq -r '.context_window.total_input_tokens // 0')

# After (실제 현재 컨텍스트 사용량 - 정확)
CURRENT_TOKENS=$(echo "$input" | jq -r '.context_window.current_usage.input_tokens // 0')
```

**핵심 차이:**
- `total_input_tokens`: 세션 전체에서 누적된 입력 토큰 (계속 증가)
- `current_usage.input_tokens`: 현재 컨텍스트 윈도우에서 실제 사용 중인 토큰

### 적용된 기술/라이브러리
- **DOM API**: `createElement`, `replaceChildren`, `textContent` (XSS 방지)
- **Promise 패턴**: 동시성 제어를 위한 락 메커니즘
- **조건부 로깅**: DEBUG 플래그 기반 console.log 제어
- **Defensive Coding**: null 체크, 타임아웃 설정
- **jq**: JSON 파싱 (Bash에서 Claude API 응답 처리)

---

## 4. 🐞 에러와 삽질의 기록 (Troubleshooting)

### [에러 1] delay is not defined

**Error Log:**
```
Failed to refresh insights for 17850890283568084: ReferenceError: delay is not defined
```

**발생 상황:**
팝업에서 동기화 버튼 클릭 시 인사이트는 정상적으로 불러오지만, 콘솔에 에러가 출력됨

**Root Cause:**
`background.js`에서 `delay()` 함수를 호출했지만, 해당 함수를 import하지 않았음.
`utils.js`에는 동일한 기능을 하는 `sleep()` 함수가 이미 존재했음.

이런 상황이 발생한 이유:
- 코드 작성 중 다른 프로젝트의 패턴(`delay`)을 무의식적으로 사용
- 자동완성 기능이 없는 환경에서 함수명 오타/불일치 발생

**Solution:**
```javascript
// Before (에러)
import { generateId, formatDate } from './shared/utils.js';
await delay(350); // ReferenceError!

// After (수정)
import { generateId, formatDate, sleep } from './shared/utils.js';
await sleep(350); // 정상 동작
```

**Prevention:**
1. 함수를 사용하기 전에 해당 모듈의 export 목록 확인
2. `utils.js`에 어떤 유틸리티 함수들이 있는지 문서화
3. IDE의 자동 import 기능 활용
4. 코드 리뷰 시 import 문과 실제 사용 함수 매칭 확인

### [에러 2] 상태표시줄 컨텍스트 바 부정확

**Error Log:**
```
상태표시줄에서 컨텍스트 사용량이 0%로 시작하지 않고 이전 세션의 누적값으로 표시됨
새 대화를 시작해도 진행률이 리셋되지 않음
```

**발생 상황:**
Claude Code 사용 중 상태표시줄의 컨텍스트 진행률 바가 새 세션에서도 높은 값으로 시작함

**Root Cause:**
`statusline.sh`에서 `total_input_tokens`(세션 누적)를 읽고 있었는데, 이는 컨텍스트 요약이 발생해도 계속 누적되는 값이었음. 실제 현재 컨텍스트 윈도우 사용량은 `current_usage.input_tokens` 필드에 있음.

**Solution:**
```bash
# Before
CURRENT_TOKENS=$(echo "$input" | jq -r '.context_window.total_input_tokens // 0')

# After
CURRENT_TOKENS=$(echo "$input" | jq -r '.context_window.current_usage.input_tokens // 0')
```

**Prevention:**
1. API 문서에서 각 필드의 정확한 의미 확인
2. `total_*` vs `current_*` 필드명의 차이 인지
3. 예상과 다른 동작 시 JSON 응답 구조 직접 확인

---

## 5. 💡 프롬프트 엔지니어링 코칭 (★ Core Feature)

오늘은 프롬프트가 매우 효과적이었습니다. 그 이유를 분석해봅시다.

### 성공 요인 분석

**😊 내가 잘한 요청:**
> "ISSUES_TO_FIX.md 파일을 읽고 추가로 확인해야하는 사항을 체크해봐"

**왜 효과적이었나:**
1. **구체적인 파일 경로 제공**: AI가 정확히 어디를 봐야 하는지 명확
2. **사전 문서화된 체크리스트**: 이슈 목록, 우선순위, 해결 방안이 이미 정리됨
3. **명확한 선택지 제공**: "전체 수정" 선택으로 범위 확정

**✅ 이 패턴을 일반화하면:**
> "**[문서 경로]**를 읽고 **[체크 기준]**에 따라 **[원하는 액션]**해줘"

### 프롬프트 성공 공식: 사전 문서화

```
좋은 프롬프트 = 명확한 컨텍스트 + 구체적인 파일/범위 + 원하는 결과물

오늘의 예시:
- 컨텍스트: "배포 전 품질 점검"
- 파일/범위: "ISSUES_TO_FIX.md에 기록된 7개 이슈"
- 결과물: "전체 수정 + 문서 업데이트"
```

**🎓 배움 포인트:**
- **누락된 정보:** 없음 - 체크리스트가 모든 정보를 담고 있었음
- **모호했던 표현:** 없음 - 선택지가 명확했음
- **개선 핵심:** **"문서화된 체크리스트 + AI"** 조합이 최강의 생산성을 만든다

---

## 6. 📦 콘텐츠 언번들링 (Unbundling Strategy)

### (1) 🧵 스레드(Threads)용 마이크로 주제

**주제 A: XSS 취약점 1분 해결법**
* **첫 줄 후킹:** "innerHTML 쓰면 해킹당할 수 있다고? 🤯"
* **핵심 내용:**
  - innerHTML vs textContent 차이
  - DOM API 헬퍼 함수 패턴
  - 실제 Before/After 코드
* **시청자 베네핏:** 웹 개발 시 보안 취약점 예방법을 배움

**주제 B: Race Condition을 Promise로 해결하기**
* **첫 줄 후킹:** "버튼 연타하면 앱이 꼬이는 이유, 알고 계셨나요?"
* **핵심 내용:**
  - 플래그 기반 vs Promise 기반 락
  - 동시성 문제의 실제 사례
  - 5줄로 해결하는 패턴
* **시청자 베네핏:** 비동기 프로그래밍의 함정과 해결법 이해

**주제 C: 배포 전 체크리스트 만들기**
* **첫 줄 후킹:** "출시 직전에 버그 터지면? 미리 막는 방법 공유"
* **핵심 내용:**
  - ISSUES_TO_FIX.md 템플릿 공유
  - 우선순위 분류법 (Critical/High/Medium/Low)
  - AI와 협업하는 품질 점검 프로세스
* **시청자 베네핏:** 체계적인 배포 프로세스 구축법

### (2) 🎬 유튜브 롱폼 아이디어

**주제: Chrome 확장 프로그램 배포 전 보안 점검 완벽 가이드**
* **제목:** "해킹 막는 코드 7가지 | Chrome Extension 보안 체크리스트"
* **썸네일 텍스트:** "innerHTML 쓰면 위험!" + 충격 이모지
* **영상 구성:**
  1. 왜 보안이 중요한가 (해킹 사례)
  2. 7가지 체크 포인트 (XSS, Race Condition 등)
  3. 실제 수정 과정 라이브 코딩
  4. 체크리스트 템플릿 배포
* **시청자 베네핏:**
  - Chrome 확장 프로그램 보안 취약점 이해
  - 복붙 가능한 해결 코드
  - 배포 전 체크리스트 템플릿

### (3) 🧩 콘텐츠 소스 매트릭스

| 카테고리 | 구체적 주제 | 추천 포맷 | 난이도 | 예상 반응 |
|---------|-----------|----------|-------|---------|
| **보안** | innerHTML XSS 취약점 해결 | 카드뉴스/숏폼 | 초급 | 💥 공유 많음 |
| **보안** | Chrome Extension 보안 체크리스트 | 롱폼/블로그 | 중급 | 📚 저장 많음 |
| **동시성** | Race Condition 쉽게 이해하기 | 숏폼/스레드 | 중급 | 🤔 댓글 많음 |
| **동시성** | Promise 기반 락 패턴 | 코드 스니펫 | 중급 | 💻 개발자 타겟 |
| **프로세스** | AI와 함께하는 코드 리뷰 | 스레드/에세이 | 초급 | 🔥 바이브코딩 |
| **프로세스** | 배포 전 체크리스트 템플릿 | 노션 템플릿 | 초급 | 📋 실용적 |
| **인사이트** | 문서화가 AI 협업의 핵심인 이유 | 에세이/롱폼 | - | 💡 인사이트 |
| **에러 해결** | "delay is not defined" 에러 | 카드뉴스 | 초급 | 🐛 공감 |
| **도구 팁** | Claude Code 상태표시줄 커스터마이징 | 스레드/숏폼 | 초급 | 🛠️ 실용 |
| **API 이해** | total vs current 토큰 차이 | 카드뉴스 | 중급 | 🧠 개념 정리 |

---

## 7. 🚀 오늘의 회고 (KPT)

### Keep (유지할 점)
- **체크리스트 기반 작업**: ISSUES_TO_FIX.md 덕분에 7개 이슈를 체계적으로 해결
- **우선순위 분류**: Critical → High → Medium → Low 순서로 효율적 진행
- **문서 업데이트**: 수정 완료 항목을 즉시 체크하여 진행 상황 투명화
- **API Rate Limit 사전 검증**: 배포 전에 제한 초과 가능성을 미리 확인

### Problem (아쉬운 점)
- **이슈 발견 시점**: 이 이슈들이 개발 초기에 발견되었으면 더 좋았을 것
- **자동화 부재**: 보안 취약점 자동 스캔 도구를 활용하지 않음
- **테스트 커버리지**: 수정한 코드에 대한 유닛 테스트가 부족

### Try (내일 시도할 것)
- [ ] Chrome 웹스토어에 최종 버전 제출
- [ ] ESLint 보안 플러그인 도입 검토 (`eslint-plugin-security`)
- [ ] 핵심 함수에 대한 유닛 테스트 추가
- [ ] 사용자 피드백 수집 채널 준비

---

## 8. 📋 내일을 위한 메모

### 미완성 기능
- 현재 MVP 기능은 모두 완성됨
- 백로그: 해시태그 필터링, 글 수정 시 Notion 업데이트, 통계 시각화

### 이어서 작업할 컨텍스트
- Chrome 웹스토어 제출 완료 (검수 대기 중)
- 보안/품질 이슈 7개 전부 수정 완료
- Vercel 서버 재배포 불필요 (클라이언트 코드만 변경)

### 내일 첫 프롬프트 예시
> "Threads → Notion Sync 확장 프로그램이 웹스토어에 게시됐어. 이제 사용자 피드백을 받을 준비를 하려고 해. 피드백 수집 방법과 버그 리포트 템플릿을 만들어줘."

---

## 📊 오늘의 통계

| 지표 | 값 |
|------|-----|
| 커밋 수 | 2 |
| 수정된 파일 | 6개 |
| 해결한 이슈 | 8개 (보안 7개 + statusline 1개) |
| 에러 발생 | 2건 (delay → sleep, total → current) |
| 콘텐츠 아이디어 | 10개 |

---

*Generated by Claude Code with /devlog command*
