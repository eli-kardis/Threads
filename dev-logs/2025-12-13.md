# 📝 개발일지: 2025-12-13

---

## 1. 📝 기본 정보

* **날짜:** 2025년 12월 13일 (금요일) 오후
* **프로젝트:** Threads to Notion Sync - Threads 게시글을 Notion에 자동 동기화하는 Chrome 확장 프로그램
* **작업 요약:** 5개 병렬 AI 에이전트로 전체 코드베이스 분석 후 12개 안전 버그 수정 및 미해결 이슈 문서화
* **진행률:** 52% (23개 버그 발견 → 12개 수정 완료, 11개 문서화)

---

## 2. 🗣️ 요구사항 역추적 (Prompt Archive)

**[요청 1]** "/review-all ... 영어 말고 한글로 해"
* **의도:** 전체 코드베이스의 품질 상태를 한눈에 파악하고 싶었음
* **AI의 해석:** 5개 전문 에이전트(코드 리뷰, 버그 탐지, 문서화, 테스트 분석, 리팩토링)를 병렬 실행하여 종합 리포트 생성
* **Gap:** 분석 깊이(빠른 스캔 vs 심층 분석)에 대한 명시 없었음

**[요청 2]** "수정했을 때 기존 앱 작동에 문제가 생기지 않는다고 판단한다면 수정 진행하세요"
* **의도:** 발견된 버그 중 안전한 것들은 바로 고쳐달라
* **AI의 해석:** "기존 앱 작동에 문제 없는" 범위를 판단하여 1차로 8개 수정 진행
* **Gap:** "안전하다"의 기준이 모호함 - AI가 자체 판단해야 했음

**[요청 3]** "더 수정해야할 건 없는거야? 아니면 즉시 수정해야하는 것만 한거야?"
* **의도:** 남은 이슈가 있는지 확인하고 추가 작업 여부 결정
* **AI의 해석:** 남은 Critical/High 이슈 목록 제시 후 선택지 제공
* **Gap:** 없음 - 좋은 follow-up 질문이었음

**[요청 4]** "(안전한 버그 수정만 선택)"
* **의도:** 리스크 없는 수정만 추가 진행
* **AI의 해석:** username 검증, OAuth 취소 처리, Chart 정리, 토큰 재시도 등 4개 추가 수정
* **Gap:** 없음 - 명확한 선택

**[요청 5]** "확인하고 수정해야하는 것들만 모아서 파일로 저장해봐"
* **의도:** 나중에 참고할 수 있도록 미해결 이슈를 문서로 남기고 싶음
* **AI의 해석:** `ISSUES_TO_FIX.md` 파일 생성하여 11개 미해결 이슈를 심각도/우선순위별로 정리
* **Gap:** 없음 - 명확한 요청

---

## 3. 🏗️ 구현 결과물 (Code & Structure)

### 변경된 파일 구조
```
Threads/
├── manifest.json              # CSP 정책 추가
├── ISSUES_TO_FIX.md           # 신규 생성: 미해결 이슈 문서
├── src/
│   ├── api/
│   │   ├── notion.js          # 페이지네이션 안전장치
│   │   └── threads.js         # 페이지네이션 무한루프 방지
│   ├── shared/
│   │   └── utils.js           # substr → slice
│   ├── storage/
│   │   └── storage.js         # 배열 버그 수정, 토큰 검증, 상수화
│   ├── ui/
│   │   ├── options.js         # OAuth 취소 처리
│   │   └── dashboard.js       # Chart.js 메모리 누수 방지
│   ├── background.js          # username 검증, 토큰 재시도 로직
│   └── content.js             # 메모리 누수 방지, Observer 정리
└── docs/dev-timeline/
    └── VibeLog_2025-12-13.md  # 작업 로그
```

### 파일 변경 요약

| 파일 경로 | 변경 유형 | 핵심 변경 내용 |
|----------|---------|--------------|
| manifest.json | 수정 | Content Security Policy 추가로 XSS 공격 방지 |
| src/shared/utils.js | 수정 | deprecated `substr()` → `slice()` 마이그레이션 |
| src/content.js | 수정 | Set 크기 제한(200개), MutationObserver 정리 로직 |
| src/storage/storage.js | 수정 | `splice(500)` 버그 → `length = 500`, 토큰 검증 추가 |
| src/api/threads.js | 수정 | 커서 중복 감지, 최대 페이지/아이템 제한 |
| src/api/notion.js | 수정 | 최대 페이지네이션 50회 제한, 응답 검증 |
| src/background.js | 수정 | username undefined 체크, 토큰 갱신 3회 재시도 |
| src/ui/options.js | 수정 | OAuth 팝업 취소 시 친화적 에러 메시지 |
| src/ui/dashboard.js | 수정 | beforeunload 시 Chart.js 인스턴스 정리 |
| ISSUES_TO_FIX.md | 생성 | 11개 미해결 이슈 문서화 (Critical 1, High 4, Medium 3, Low 4) |

### 핵심 구현 로직

**1. 페이지네이션 무한루프 방지 (threads.js)**
```javascript
// 이미 방문한 커서인지 추적하여 무한 루프 방지
const seenCursors = new Set();

do {
  if (cursor && seenCursors.has(cursor)) {
    console.warn('Pagination loop detected, breaking');
    break;
  }
  if (cursor) seenCursors.add(cursor);

  // 최대 제한 초과 시에도 종료
  if (pageCount >= PAGINATION_LIMITS.MAX_PAGES) break;
  if (allThreads.length >= PAGINATION_LIMITS.MAX_ITEMS) break;

  // ... API 호출 ...
} while (cursor);
```

**2. 토큰 갱신 재시도 로직 (background.js)**
```javascript
const TOKEN_REFRESH_CONFIG = { MAX_RETRIES: 3, RETRY_DELAY_MS: 2000 };

for (let attempt = 1; attempt <= TOKEN_REFRESH_CONFIG.MAX_RETRIES; attempt++) {
  try {
    const result = await threadsApi.refreshLongLivedToken(token);
    return { success: true, reason: 'refreshed' };
  } catch (error) {
    console.warn(`Attempt ${attempt} failed:`, error.message);
    if (attempt < TOKEN_REFRESH_CONFIG.MAX_RETRIES) {
      await new Promise(r => setTimeout(r, TOKEN_REFRESH_CONFIG.RETRY_DELAY_MS));
    }
  }
}
return { success: false, reason: 'refresh_failed' };
```

### 적용된 기술/라이브러리
- **Chrome Extension Manifest V3**: 서비스 워커 기반 백그라운드 처리
- **Content Security Policy (CSP)**: `script-src 'self'`로 XSS 방지
- **JavaScript ES6+**: Optional Chaining(?.), Set, async/await
- **Chart.js**: 일별 조회수 시각화 (메모리 관리 추가)
- **MutationObserver**: DOM 변경 감지 (라이프사이클 관리 추가)

---

## 4. 🐞 에러와 삽질의 기록 (Troubleshooting)

**[에러 없음 - 사전 예방적 버그 수정]**

오늘은 **5개 AI 에이전트를 통한 사전 분석**으로 런타임 에러 없이 23개 잠재적 버그를 발견하고 12개를 수정했습니다.

발견된 버그 유형:
| 유형 | 개수 | 예시 |
|-----|-----|-----|
| **Critical** | 5 | innerHTML XSS, 무한 루프 |
| **Major** | 11 | Race Condition, 메모리 누수, 토큰 검증 누락 |
| **Minor** | 7 | deprecated API, 매직 넘버 |

**가장 흥미로웠던 버그: `splice()` 오용**

```javascript
// ❌ 잘못된 코드 - 인덱스 500 이후만 제거 (배열을 500개로 제한 안 됨)
if (history.length > 500) {
  history.splice(500);
}

// ✅ 올바른 코드 - 배열 길이를 500으로 제한
if (history.length > 500) {
  history.length = 500;
}
```

**Prevention:** JavaScript의 `splice(n)`은 "n번째부터 끝까지 제거"입니다. 배열 크기 제한 시에는 `array.length = n` 또는 `array.slice(0, n)`을 사용하세요.

---

## 5. 💡 프롬프트 엔지니어링 코칭

**😅 내가 했던 요청:**
> "수정했을 때 기존 앱 작동에 문제가 생기지 않는다고 판단한다면 수정 진행하세요"

**✅ 이렇게 했으면 더 좋았다:**
> "코드 리뷰 결과를 바탕으로 **기존 기능에 영향 없는 안전한 버그만** 수정해줘. 구체적으로:
> 1. 사이드이펙트 없는 버그 (deprecated API, 상수화, 검증 로직)
> 2. 방어적 코드 추가 (null 체크, 무한루프 방지)
> 3. Critical 이슈 중 동작 변경 없이 수정 가능한 것
>
> 수정하기 애매한 건 목록만 정리해줘."

**🎓 배움 포인트:**
- **누락된 정보:** "안전하다"의 기준 (동작 변경 여부, 테스트 필요 여부 등)
- **모호했던 표현:** "문제가 생기지 않는다고 판단한다면" - AI에게 판단 기준 위임
- **개선 핵심:** 수정 범위를 구체적인 카테고리로 명시하면 AI가 더 정확하게 작업할 수 있음

---

## 6. 📦 콘텐츠 언번들링 (Unbundling Strategy)

### (1) 🧵 스레드(Threads)용 마이크로 주제

**주제 A: JavaScript splice() 함정**
* **첫 줄 후킹:** "배열을 500개로 제한하려고 splice(500) 썼는데... 왜 안 돼?"
* **시청자 베네핏:** splice() vs slice() vs length 차이를 확실히 이해하고 버그 예방

**주제 B: AI 코드 리뷰 실전**
* **첫 줄 후킹:** "내 코드에서 버그 23개 찾는 데 걸린 시간? 5분"
* **시청자 베네핏:** AI 에이전트를 활용한 효율적인 코드 품질 관리 방법

**주제 C: 토큰 갱신 재시도 패턴**
* **첫 줄 후킹:** "API 토큰 만료됐다고 앱이 멈추면 안 되잖아요"
* **시청자 베네핏:** 네트워크 요청의 재시도 로직 구현 패턴 습득

**주제 D: Chrome Extension 보안**
* **첫 줄 후킹:** "확장 프로그램 만들 때 이거 안 하면 해킹당할 수 있음"
* **시청자 베네핏:** CSP 정책의 중요성과 적용 방법 이해

### (2) 🎬 유튜브 롱폼 아이디어 주제

**주제 A: AI 5명이 내 코드 리뷰하면 생기는 일**
* **제목:** "Claude 에이전트 5개로 코드 리뷰 시켜봄 (버그 23개 발견)"
* **시청자 베네핏:** AI 병렬 에이전트 활용법, 실제 버그 수정 과정 라이브 시청

**주제 B: 바이브코딩으로 Chrome 확장 만들기**
* **제목:** "코딩 1도 모르는데 Chrome 확장 프로그램 만든 썰"
* **시청자 베네핏:** Threads to Notion Sync 개발 전 과정, 프롬프트 엔지니어링 실전

**주제 C: 안전한 버그 수정의 기술**
* **제목:** "버그 고치다 앱 터지는 거 막는 법 (실전 12가지)"
* **시청자 베네핏:** 사이드이펙트 없는 리팩토링 전략, 방어적 프로그래밍

### (3) 🧩 콘텐츠 소스 매트릭스

| 카테고리 | 구체적 주제 | 추천 포맷 | 난이도 |
|---------|-----------|----------|-------|
| 에러 해결 | splice() vs slice() 차이점 | 카드뉴스 | 입문 |
| 에러 해결 | 무한 루프 방지 패턴 | 숏폼 | 초급 |
| 프롬프트 팁 | "안전한 수정만 해줘" 올바른 요청법 | 스레드 | 입문 |
| 프롬프트 팁 | AI 코드 리뷰 프롬프트 템플릿 | 블로그 | 초급 |
| 인사이트 | 왜 방어적 프로그래밍이 중요한가 | 에세이 | 중급 |
| 인사이트 | 기술 부채 관리: 문서화의 힘 | 롱폼 | 중급 |
| 튜토리얼 | Chrome Extension CSP 설정법 | 유튜브 | 초급 |
| 튜토리얼 | OAuth 에러 핸들링 베스트 프랙티스 | 블로그 | 중급 |
| 비하인드 | AI 5개 에이전트 병렬 코드 리뷰 후기 | 브이로그 | 입문 |
| 도구 리뷰 | Claude Code /review-all 기능 활용법 | 숏폼 | 입문 |

---

## 7. 🚀 오늘의 회고 (KPT)

### Keep (유지할 점)
- **AI 병렬 에이전트 활용:** 5개 전문 에이전트로 다각도 분석 → 혼자서는 못 찾았을 버그 23개 발견
- **단계적 수정 전략:** 전체 수정 vs 안전 수정 선택지 제시 → 리스크 관리하며 진행
- **문서화 습관:** 미해결 이슈를 `ISSUES_TO_FIX.md`로 정리 → 기술 부채 가시화

### Problem (아쉬운 점)
- **프롬프트 모호성:** "문제가 생기지 않는다고 판단한다면"이라는 표현은 AI에게 판단 기준을 위임한 것
- **테스트 커버리지 0%:** 버그는 고쳤지만 테스트 코드 없이 수정 → 회귀 버그 위험
- **Critical 이슈 미해결:** innerHTML XSS 취약점은 아직 남아있음

### Try (내일 시도할 것)
1. `ISSUES_TO_FIX.md`의 Critical 이슈(innerHTML XSS) 수정
2. 테스트 코드 작성 시작 (최소 background.js 핵심 함수)
3. 프롬프트 작성 시 "안전하다"의 기준을 구체적 카테고리로 명시하기

---

## 8. 📋 내일을 위한 메모

### 미완성 기능
- innerHTML XSS 취약점 수정 (options.js 7곳)
- Race Condition 해결 (background.js isSyncing 플래그)
- Storage 키 불일치 수정 (tokenExpiresAt vs threadsTokenExpiresAt)

### 이어서 작업할 컨텍스트
- `ISSUES_TO_FIX.md` 파일에 우선순위별로 정리되어 있음
- Critical 1개 → High 4개 → Medium 3개 순서로 진행 권장
- 각 이슈에 현재 코드와 해결 방안이 포함되어 있음

### 내일 첫 프롬프트 예시
> "어제 `ISSUES_TO_FIX.md`에 정리한 이슈 중 Critical인 'innerHTML XSS 취약점'을 수정해줘. options.js의 innerHTML을 textContent와 DOM API로 교체하고, 수정 후 기존 기능이 동일하게 동작하는지 확인해줘."

---

*이 개발일지는 바이브코딩 회고 파트너 Claude와 함께 작성되었습니다.*
