# 📓 개발일지: 2025-12-15

---

## 1. 📝 기본 정보

* **날짜:** 2025년 12월 15일 (일) 15:30
* **프로젝트:** Threads to Notion Sync - Threads 게시글을 Notion에 자동 동기화하는 Chrome 확장 프로그램
* **작업 요약:** 동기화 버튼 간 로직 불일치 해결 및 API Rate Limit 최적화
* **진행률:** 90% (Meta 앱 검수 대기 중, 기능 개발 완료)

---

## 2. 🗣️ 요구사항 역추적 (Prompt Archive)

**[요청 1]** "아직도 메인화면에서 동기화 시작 버튼을 누르면 노션에 동기화가 잘 되는데, 여기서 지금 동기화를 누르면 새로운 글이 동기화가 안돼"

* **의도:** 팝업 화면의 "지금 동기화" 버튼이 새 게시글을 감지하지 못하는 버그 해결
* **AI의 해석:** 두 버튼(popup vs options)이 서로 다른 함수를 호출하고 있었고, 필터링 로직이 달랐음을 파악. popup은 `lastSyncTime` 기반, options는 ID 기반 체크를 사용 중이었음
* **Gap:** 처음에는 "왜 안 되는지"만 물었고, 두 버튼의 설계 의도 차이에 대한 정보가 없었음

**[요청 2]** "왜 옵션의 버튼과 팝업의 버튼의 동작 차이가 있는거야?"

* **의도:** 버그인지, 의도적 설계인지 확인
* **AI의 해석:** 원래 설계 의도를 분석하여 설명 - popup은 "빠른 일상 동기화", options는 "전체 복구용"으로 구분되어 있었음
* **Gap:** 이 질문 덕분에 근본 원인을 파악할 수 있었음. 처음부터 "두 버튼의 차이가 뭔지"를 물었으면 더 빨랐을 것

**[요청 3]** "5분에 10개로 변경하자. 팝업 버튼도 50개 말고 30개로 변경해줘"

* **의도:** API 호출량을 줄여 Rate Limit 방지
* **AI의 해석:** 구체적인 수치가 명시되어 즉시 구현 가능했음
* **Gap:** 없음 - 명확하고 구체적인 요청의 좋은 예시

---

## 3. 🏗️ 구현 결과물 (Code & Structure)

**변경된 파일 구조:**
```
Threads/
└── src/
    ├── background.js      ← 핵심 수정 (performSync 파라미터화)
    ├── storage/
    │   └── storage.js     ← syncInterval 기본값 변경
    └── ui/
        └── options.js     ← syncInterval 기본값 변경
```

**파일 변경 요약:**

| 파일 경로 | 변경 유형 | 핵심 변경 내용 |
|----------|---------|--------------|
| src/background.js | 수정 | `performSync()`에 `limit` 파라미터 추가, `lastSyncTime` 필터링 → ID 기반으로 변경 |
| src/storage/storage.js | 수정 | 기본 `syncInterval`: 1분 → 5분 |
| src/ui/options.js | 수정 | 기본 `syncInterval`: 1분 → 5분 |

**핵심 구현 로직:**

```javascript
// background.js - 동기화 함수에 limit 파라미터 추가
async function performSync(options = {}) {
  const { limit = 30 } = options;  // 기본값 30개

  // 최근 게시글만 조회 (최신순)
  const response = await threadsApi.getUserThreads(settings.threadsToken, { limit });
  const recentThreads = (response.data || [])
    .filter(t => !t.is_quote_post && t.media_type !== 'REPOST_FACADE')
    .map(threadsApi.normalizeThread);

  // ID 기반으로 이미 동기화된 글 스킵 (시간 기반 X)
  for (const thread of recentThreads) {
    const alreadySynced = await storage.isThreadSynced(thread.id);
    if (alreadySynced) {
      skippedCount++;
      continue;
    }
    // 새 글만 Notion에 동기화
    await syncThreadToNotion(thread, settings);
  }
}
```

```javascript
// 호출 시 용도별 limit 차별화
// 자동 동기화 (5분마다): 10개만 조회
await performSync({ limit: 10 });

// 수동 동기화 (팝업 버튼): 30개 조회
return await performSync({ limit: 30 });
```

**적용된 기술/라이브러리:**
- Chrome Extension APIs (Storage, Alarms, Runtime)
- Threads Graph API (Meta)
- Notion API

---

## 4. 🐞 에러와 삽질의 기록 (Troubleshooting)

**[삽질 1] - 잘못된 문제 분석으로 인한 과잉 수정**

* **발생 상황:** popup의 "지금 동기화"가 안 된다는 보고를 받고, `lastSyncTime` 필터링을 완전히 제거해버림
* **잘못된 수정:**
```javascript
// 모든 게시글을 조회하도록 변경 (비효율적!)
const allThreads = await threadsApi.getAllUserThreads(settings.threadsToken, {});
```
* **문제점:** 1분마다 전체 게시글을 페이지네이션으로 조회 → API 호출량 폭발 → Rate Limit 위험
* **사용자 피드백:** "1분에 50개씩 계속 불러오면 리밋 안걸려?"
* **Root Cause:** 문제의 근본 원인(두 버튼의 로직 차이)을 파악하지 않고, 증상만 보고 수정함
* **Solution:** 원래 구조 유지하면서 필터링 방식만 ID 기반으로 통일

**[이슈] - API access blocked**

* **Error Log:**
```
Sync failed: Error: Failed to verify user identity: API access blocked
```
* **상황:** Meta Developer 앱이 아직 검수 대기 중이라 테스터 외 사용 불가
* **해결:** 코드 문제가 아님 - Meta 앱 검수 완료 대기 필요

**Prevention (다음을 위한 교훈):**
1. 버그 수정 전에 "왜 이렇게 설계되었는지" 먼저 파악할 것
2. 수정 후 "이게 다른 곳에 영향을 주는지" 생각할 것
3. API 호출량은 항상 고려해야 할 중요한 제약조건

---

## 5. 💡 프롬프트 엔지니어링 코칭 (★ Core Feature)

**😅 내가 했던 요청:**
> "아직도 메인화면에서 동기화 시작 버튼을 누르면 노션에 동기화가 잘 되는데, 여기서 지금 동기화를 누르면 새로운 글이 동기화가 안돼"

**✅ 이렇게 했으면 더 좋았다:**
> "popup과 options 페이지에 각각 동기화 버튼이 있어. options의 '동기화 시작'은 잘 되는데 popup의 '지금 동기화'만 새 글을 못 찾아. 두 버튼이 호출하는 함수와 로직을 비교해서 차이점을 알려줘."

**🎓 배움 포인트:**
- **누락된 정보:** 어떤 버튼이 어디에 있는지(popup vs options), 각각 어떤 함수를 호출하는지
- **모호했던 표현:** "여기서"라는 표현 - 스크린샷이 있었지만 코드 레벨의 구분이 없었음
- **개선 핵심:**
  - 비교 대상을 명확히 할 것 (A는 되는데 B는 안 된다)
  - "왜"를 먼저 물을 것 (증상 → 원인 순서로 접근)
  - 구체적인 수치가 필요하면 직접 제시할 것

---

## 6. 📦 콘텐츠 언번들링 (Unbundling Strategy)

### (1) 🧵 스레드(Threads)용 마이크로 주제

**주제 A: "같은 기능, 다른 로직" 함정**
* **첫 줄 후킹:** "앱에 '동기화' 버튼이 2개 있는데, 하나만 작동한다면?"
* **시청자 베네핏:** 동일 기능을 여러 곳에서 구현할 때 로직 통일의 중요성 학습

**주제 B: API Rate Limit 계산법**
* **첫 줄 후킹:** "1분마다 50개씩 API 호출하면... 시간당 120회. 한계는 200회. 🚨"
* **시청자 베네핏:** 외부 API 사용 시 호출량 계산하는 습관 들이기

**주제 C: 시간 기반 vs ID 기반 필터링**
* **첫 줄 후킹:** "마지막 동기화 시간 이후 글만 가져오면 안전할까? 아니."
* **시청자 베네핏:** 데이터 동기화 시 안정적인 중복 체크 방법 이해

### (2) 🎬 유튜브 롱폼 아이디어 주제

**주제: "Chrome 확장 프로그램, 실시간 동기화 설계하기"**
* **제목:** "1분 vs 5분, API 호출 전략이 앱의 운명을 바꾼다"
* **시청자 베네핏:**
  - 백그라운드 동기화 알람 설정 방법
  - API Rate Limit 고려한 설계
  - 효율적인 중복 체크 로직 구현

### (3) 🧩 콘텐츠 소스 매트릭스

| 카테고리 | 구체적 주제 | 추천 포맷 | 난이도 |
|---------|-----------|----------|-------|
| 설계 원칙 | 동일 기능은 동일 로직으로 통일하라 | 스레드/카드뉴스 | ⭐⭐ |
| API 최적화 | Rate Limit 계산과 호출량 최적화 | 숏폼/릴스 | ⭐⭐⭐ |
| 데이터 동기화 | 시간 기반 vs ID 기반 필터링 비교 | 블로그/롱폼 | ⭐⭐⭐ |
| 디버깅 팁 | "증상"보다 "원인"을 먼저 파악하라 | 스레드 | ⭐ |
| Chrome Extension | 백그라운드 알람으로 자동 동기화 구현 | 유튜브 튜토리얼 | ⭐⭐⭐⭐ |
| 프롬프트 팁 | AI에게 "비교 분석"을 요청하는 법 | 스레드 | ⭐ |

---

## 7. 🚀 오늘의 회고 (KPT)

### Keep (유지할 점)
- 사용자의 질문("왜 차이가 있어?")을 통해 근본 원인을 파악한 것
- Rate Limit 문제를 사전에 인지하고 최적화한 것
- 구체적인 수치(5분/10개, 30개)를 제시하여 명확하게 요구사항 전달

### Problem (아쉬운 점)
- 처음에 문제를 잘못 분석하여 비효율적인 코드로 수정했다가 롤백
- "두 버튼의 차이"를 먼저 분석하지 않고 증상만 보고 수정 시도
- Meta API 검수 상태를 미리 확인하지 않아 테스트 불가 상황 발생

### Try (내일 시도할 것)
- Meta Developer 앱 검수 상태 확인 및 필요시 추가 정보 제출
- 토큰 유효성 테스트를 curl로 직접 확인
- Chrome Web Store 비공개 테스트 등록 검토

---

## 8. 📋 내일을 위한 메모

### 미완성 기능
- Meta 앱 검수 완료 대기 (API access blocked 해결 필요)
- Chrome Web Store 등록 (Meta 검수 완료 후)

### 이어서 작업할 컨텍스트
- 현재 토큰은 유효함 (2026년 2월 10일 만료)
- "API access blocked"는 코드 문제가 아닌 Meta 앱 상태 문제
- 수정된 동기화 로직: popup 30개, 자동 10개/5분, 모두 ID 기반 체크

### 내일 첫 프롬프트 예시
> "Meta 앱 검수가 완료됐어. 토큰이 정상 작동하는지 curl로 테스트하고, 확장 프로그램에서 동기화 테스트해줘. 성공하면 Chrome Web Store에 비공개 테스트로 등록하는 방법도 알려줘."

---

*Generated by Vibe Coding Assistant | 2025-12-15*
